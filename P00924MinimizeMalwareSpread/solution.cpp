#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
  vector<int> parents;
  vector<int> ranks;
  vector<bool> isInitial;
  int find(int vertex) {
    if (parents[vertex] != vertex) {
      parents[vertex] = find(parents[vertex]);
    }

    return parents[vertex];
  };

  int unionSet(int u, int v) {
    int pu = find(u);
    int pv = find(v);
    // join two components
    if (pu != pv) {
      if (ranks[pu] > ranks[pv]) {
        parents[pv] = pu;
        return pu;
      } else if (ranks[pu] < ranks[pv]) {
        parents[pu] = pv;
        return pv;
      } else {
        parents[pv] = pu;
        ranks[pu]++;
      }
    }

    return pu;
  };

public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    int n = graph.size();
    int m = initial.size();
    vector<bool> visited(n, false);
    parents.resize(n, -1);
    ranks.resize(n, 0);
    isInitial.resize(n, false);

    for (int i = 0; i < n; i++) {
      parents[i] = i;
    }

    for (int i = 0; i < m; i++) {
      isInitial[initial[i]] = true;
    }

    // vector<int> queue;

    // for (int i = 0; i < m; i++) {
    //   queue.push_back(initial[i]);
    // }

    // while (!queue.empty()) {
    //   auto v = queue[0];
    //   queue.erase(queue.begin());
    //
    //   if (visited[v]) {
    //     continue;
    //   }
    //
    //   visited[v] = true;
    //
    //   for (int i = 0; i < n; i++) {
    //     if (i == v)
    //       continue;
    //     if (graph[v][i]) {
    //       unionSet(v, i);
    //       if (!visited[i]) {
    //         queue.push_back(i);
    //       }
    //     }
    //   }
    // }
    //

    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        if (graph[i][j]) {
          unionSet(i, j);
        }
      }
    }

    map<int, int> componentsSize, initialsInComponents;
    for (int i = 0; i < m; i++) {
      int component = find(initial[i]);
      initialsInComponents[component]++;
    }

    for (int i = 0; i < n; i++) {
      int component = find(i);
      if (!initialsInComponents.count(component)) {
        continue;
      }

      componentsSize[component]++;
    }

    int result = INT_MAX;
    int maxComponentSize = INT_MIN;

    for (int i = 0; i < m; i++) {
      int component = find(initial[i]);
      if (initialsInComponents[component] == 1) {
        if (componentsSize[component] > maxComponentSize) {
          maxComponentSize = componentsSize[component];
          result = initial[i];
        } else if (componentsSize[component] == maxComponentSize) {
          result = min(result, initial[i]);
        }
      } else {
        if (result == INT_MAX) {
          result = initial[i];
        } else {
          result = min(result, initial[i]);
        }
      }
    }

    return result;
  }
};

int main() {
  // cin.tie(0)->sync_with_stdio(0);
  // cin.exceptions(cin.failbit);

  int n, m;
  cin >> n >> m;

  vector<vector<int>> graph(n, vector<int>(n));

  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      cin >> graph[i][j];
    }
  }

  vector<int> initial(m);

  for (int i = 0; i < m; i++) {
    cin >> initial[i];
  }

  cout << Solution().minMalwareSpread(graph, initial) << endl;
}
